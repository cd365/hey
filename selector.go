package hey

import (
	"bytes"
	"fmt"
	"strings"
)

type JoinType string

const (
	JoinMaster JoinType = "MASTER"
	JoinInner           = "INNER"
	JoinLeft            = "LEFT"
	JoinRight           = "RIGHT"
	JoinFull            = "FULL"
)

type Joiner interface {
	// As set current table name as alias-name
	As(as string) Joiner

	// Alias get current table name as alias-name
	Alias() string

	// Asa set current table name as <a>
	Asa() Joiner

	// Asb set current table name as <b>
	Asb() Joiner

	// Asc set current table name as <c>
	Asc() Joiner

	// Asd set current table name as <d>
	Asd() Joiner

	// Ase set current table name as <e>
	Ase() Joiner

	// Asf set current table name as <f>
	Asf() Joiner

	// Table get current table name
	Table() string

	// Name get the name used by the current table, aliases take precedence
	Name() string

	// Field set the connection query finally needs to query the field list of this table
	Field(field ...string) Joiner

	// QueryField get the connection query finally needs to query the field list of this table
	QueryField() []string

	// FieldFull the table's field full name value
	FieldFull(field string) string

	// On the criteria for joining the current table query
	On(on string, filter ...Filter) Joiner

	// OnEqual the criteria for joining the current table query, left = right
	OnEqual(left string, right string, filter ...Filter) Joiner

	// Result the current table joins the final sql script and parameters generated by the query
	Result() (prepare string, args []interface{})
}

type Join struct {
	style     JoinType      // join type
	table     string        // table name | SQL statement
	as        string        // table alias name
	on        string        // join condition
	tableArgs []interface{} // if table value is a SQL statement
	field     []string      // the connection query finally needs to query the field list of this table
	filter    Filter        // used for condition after on
	query     []string      // query the fields of the table
}

func (s *Join) As(as string) Joiner {
	s.as = as
	return s
}

func (s *Join) Alias() string {
	return s.as
}

func (s *Join) Asa() Joiner {
	s.As("a")
	return s
}

func (s *Join) Asb() Joiner {
	s.As("b")
	return s
}

func (s *Join) Asc() Joiner {
	s.As("c")
	return s
}

func (s *Join) Asd() Joiner {
	s.As("d")
	return s
}

func (s *Join) Ase() Joiner {
	s.As("e")
	return s
}

func (s *Join) Asf() Joiner {
	s.As("f")
	return s
}

func (s *Join) Table() string {
	return s.table
}

func (s *Join) Name() string {
	if s.as != "" {
		return s.as
	}
	return s.table
}

func (s *Join) prefix() string {
	return fmt.Sprintf("%s.", s.Name())
}

func (s *Join) Field(field ...string) Joiner {
	prefix := s.prefix()
	for k, v := range field {
		if !strings.Contains(v, prefix) {
			field[k] = prefix + v
		}
	}
	s.field = field
	return s
}

func (s *Join) QueryField() []string {
	return s.field
}

func (s *Join) FieldFull(field string) string {
	prefix := s.prefix()
	if !strings.Contains(field, prefix) {
		return prefix + field
	}
	return field
}

func (s *Join) On(on string, filter ...Filter) Joiner {
	s.on = on
	s.filter = FilterJoin(false, filter...)
	return s
}

func (s *Join) OnEqual(left string, right string, filter ...Filter) Joiner {
	return s.On(fmt.Sprintf("%s = %s", left, right), filter...)
}

func (s *Join) Result() (prepare string, args []interface{}) {
	if s.style == JoinMaster || s.table == "" || s.on == "" {
		return
	}
	buf := &bytes.Buffer{}
	buf.WriteString(fmt.Sprintf("%s JOIN %s", s.style, s.table))
	args = s.tableArgs
	if s.as != "" {
		buf.WriteString(fmt.Sprintf(" AS %s", s.as))
	}
	buf.WriteString(fmt.Sprintf(" ON %s", s.on))
	if s.filter != nil {
		key, val := s.filter.Result()
		if key != "" {
			buf.WriteString(fmt.Sprintf(" AND %s", key))
			args = append(args, val...)
		}
	}
	prepare = buf.String()
	return
}

func initJoin(style JoinType, table string, args ...interface{}) Joiner {
	return &Join{
		style:     style,
		table:     table,
		tableArgs: args,
	}
}

func MasterJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinMaster, table, args...)
}

func InnerJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinInner, table, args...)
}

func LeftJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinLeft, table, args...)
}

func RightJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinRight, table, args...)
}

func FullJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinFull, table, args...)
}

type Order struct {
	Order []string
}

func NewOrder() *Order {
	return &Order{}
}

func (s *Order) Asc(columns ...string) *Order {
	for _, column := range columns {
		if column != "" {
			s.Order = append(s.Order, fmt.Sprintf("%s ASC", column))
		}
	}
	return s
}

func (s *Order) Desc(columns ...string) *Order {
	for _, column := range columns {
		if column != "" {
			s.Order = append(s.Order, fmt.Sprintf("%s DESC", column))
		}
	}
	return s
}

func (s *Order) Result() string {
	return strings.Join(s.Order, ", ")
}

func Alias(name string, alias ...string) string {
	for i := len(alias) - 1; i >= 0; i-- {
		if alias[i] != "" {
			return fmt.Sprintf("%s AS %s", name, alias[i])
		}
	}
	return name
}

func FieldMerge(fields ...[]string) (result []string) {
	for _, field := range fields {
		result = append(result, field...)
	}
	return
}

func SubQuery(prepare string) string {
	return fmt.Sprintf("( %s )", prepare)
}
