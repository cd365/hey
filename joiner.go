package hey

import (
	"fmt"
)

type JoinType string

const (
	JoinMaster JoinType = "MASTER"
	JoinInner           = "INNER"
	JoinLeft            = "LEFT"
	JoinRight           = "RIGHT"
	JoinFull            = "FULL"
)

type Joiner interface {
	// As set current table name as alias-name
	As(as string) Joiner
	// Asa set current table name as <a>
	Asa() Joiner
	// Asb set current table name as <b>
	Asb() Joiner
	// Asc set current table name as <c>
	Asc() Joiner
	// OnEqual the criteria for joining the current table query
	OnEqual(left string, right string) Joiner
	// Filter join query additional filtering criteria
	Filter(filter Filter) Joiner
	// Query specify the fields to be queried in this table
	Query(field ...string) Joiner
	// Table name of table
	Table() string
	// Using exposes the final table name for using, alias name first
	Using() string
	// F for get table_name.column; (email => a.email | email => account.email)
	F(field string) string
	// Result the current table joins the final sql script and parameters generated by the query
	Result() (prepare string, args []interface{})
	// Select list of fields for the current table query
	Select() []string
}

type Join struct {
	style     JoinType      // join type
	table     string        // table name | SQL statement
	as        string        // table alias name
	on        string        // join condition
	tableArgs []interface{} // if table value is a SQL statement
	filter    Filter        // used for condition after on
	query     []string      // query the fields of the table
	using     string        // exposes the final table name for using, alias name first
}

func (s *Join) As(as string) Joiner {
	if as != "" {
		s.as = as
		s.using = as
	}
	return s
}

func (s *Join) Asa() Joiner {
	s.As("a")
	return s
}

func (s *Join) Asb() Joiner {
	s.As("b")
	return s
}

func (s *Join) Asc() Joiner {
	s.As("c")
	return s
}

func (s *Join) OnEqual(left string, right string) Joiner {
	s.on = fmt.Sprintf("%s = %s", left, right)
	return s
}

func (s *Join) Filter(filter Filter) Joiner {
	s.filter = filter
	return s
}

func (s *Join) Query(query ...string) Joiner {
	s.query = query
	return s
}

func (s *Join) Table() string {
	return s.table
}

func (s *Join) Using() string {
	return s.using
}

func (s *Join) F(field string) string {
	return fmt.Sprintf("%s.%s", s.using, field)
}

func (s *Join) Result() (prepare string, args []interface{}) {
	if s.style == JoinMaster || s.table == "" || s.on == "" {
		return
	}
	prepare = fmt.Sprintf("%s JOIN %s", s.style, s.table)
	args = s.tableArgs
	if s.as != "" {
		prepare = fmt.Sprintf("%s AS %s", prepare, s.as)
	}
	prepare = fmt.Sprintf("%s ON %s", prepare, s.on)
	if s.filter != nil {
		key, val := s.filter.Result()
		if key != "" {
			prepare = fmt.Sprintf("%s AND %s", prepare, key)
			args = append(args, val...)
		}
	}
	return
}

func (s *Join) Select() (result []string) {
	length := len(s.query)
	result = make([]string, length)
	for i := 0; i < length; i++ {
		result[i] = s.F(s.query[i])
	}
	return
}

func initJoin(style JoinType, table string, args ...interface{}) Joiner {
	return &Join{
		style:     style,
		table:     table,
		tableArgs: args,
		using:     table,
	}
}

func MasterJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinMaster, table, args...)
}

func InnerJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinInner, table, args...)
}

func LeftJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinLeft, table, args...)
}

func RightJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinRight, table, args...)
}

func FullJoin(table string, args ...interface{}) Joiner {
	return initJoin(JoinFull, table, args...)
}
